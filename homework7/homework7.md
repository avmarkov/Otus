# Домашняя работа № 7. Механизм блокировок.

### 1. Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
> Посмотрим текущее значение таймаута
> ```sql
> postgres=# SHOW deadlock_timeout;
> ```
>
> Результат:
>
> <image src="images/deadlock_timeout.png" alt="deadlock_timeout">

> Поменяем deadlock_timeout
> ```sql
> postgres=# ALTER SYSTEM SET deadlock_timeout ='200ms';
> ```

> Включим запись в лог, в случае, если транзакция ждала дольше, чем deadlock_timeout:
> ```sql
> postgres=# ALTER SYSTEM SET log_lock_waits = on;
> postgres=# SELECT pg_reload_conf();
> ```
> Результат:
>
> <image src="images/deadlock_timeout2.png" alt="deadlock_timeout2">

> Воспроиззведем ситуацию с записью в журнал. Я создал таблицу lock_table(field1 integer), вставил одно значение = 1. И запустил две транзакции в двух разных сессиях, которые обновляли единственное значение этoго поля.
> Соответсвенно, вторая транзакция ожидала завершения первой:
>
> <image src="images/lock1.png" alt="lock1">

> В логи появились следующие записи о блокировки:
>
> <image src="images/log_lock.png" alt="log_lock">

### 2. Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

### 3. Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

### 4. Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?